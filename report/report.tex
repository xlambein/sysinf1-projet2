\documentclass[a4paper,10pt]{article}

\usepackage{../latex/mystyle}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}

\lstset{
    basicstyle=\ttfamily,
    frame=single,
    numbers=left,
    breaklines=true,
}

\begin{document}

\begin{center}
\begin{tabu} to \textwidth {lX[c]r}
    Xavier Lambein & \large{\textbf{Projet 2: Rapport}} & Victor Lecomte \\
    54621300 & LSINF1252 & 65531300 \\
    \hline
\end{tabu}
\end{center}

\vspace{0.7cm}

\subsection*{Concept}

Dans le cadre de ce projet, nous avons décidé de ne pas adopter une simple approche producteur-consommateur avec parallélisation externe. À la place, nous avons développé un algorithme qui utilise les caractéristiques de l'énoncé et s'adapte au mieux aux informations qu'il obtient au fur et à mesure.

Puisque l'énoncé mentionne que tous les facteurs premiers sauf un sont utilisés plus d'une fois, on peut tirer un avantage considérable des facteurs premiers déjà trouvés. Notre algorithme profite donc de cette propriété à chaque fois qu'il trouve un facteur premier, en le testant sur tous les autres nombres, et tant que la lecture n'est pas terminée, en essayant de diviser un nombre lu par chaque facteur premier déjà trouvé.

Cette approche permet une diminution très significative du travail de factorisation, mais comme nous nous y attendions nous avons trouvé des cas où il cette approche le ralentit. Nous allons discuter de ces problèmes dans la section d'analyse des performances. Toutefois, nous avons tout de même choisi de faire comme ça, pour le challenge de synchronisation et d'organisation qu'il représentait, et pour le temps économisé pour des cas typiques (grands facteurs premiers, 2 à 3 occurences de chaque premier).

\subsection*{Architecture du programme}

Notre programme se décompose en trois parties différentes, qui possèdent leur fonction propre: la boucle principale, les \emph{readers} et les \emph{factorizers}. Les \emph{readers} sont des threads servant à lire des entiers depuis les entrées pour les placer dans une liste interne; les \emph{factorizers} sont des threads parcourant un entier pour en trouver les facteurs; enfin, la boucle principale sert à synchroniser les \emph{factorizers} pour changer l'entier courant à factoriser \texttt{to\_fact} et éventuellement terminer le programme.

Ces parties partagent deux listes d'entiers qui sont la \emph{waiting list} et la \emph{prime list}. La première contient tous les nombres à factoriser. Elle possède deux entrées: les \emph{readers}, évidemment, mais aussi les \emph{factorizers}, comme nous allons le voir plus loin.

La seconde contient tous les facteurs premiers trouvés, et n'est utilisée que temporairement, tant qu'il reste des \emph{readers} actifs. En effet, tant que tous les nombres n'ont pas été lus, il est impossible d'être certain que ces facteurs ne sont pas solution, et il est donc nécessaire de les garder. Cette liste ne possède qu'une seule entrée, et il s'agit de la boucle principale.

Chaque nombre stocké dans \emph{waiting list} et dans la \emph{prime list} transporte également deux informations: le fichier d'où il provient et son nombre d'occurrences, c'est-à-dire, s'il s'agit d'un facteur (premier ou non), le nombre de fois qu'il apparaît (divise un nombre). Cela est nécessaire pour vérifier si le facteur est une solution.

Dans la suite, nous allons expliquer en détail le fonctionnement de chaque partie.

\subsubsection*{Les \emph{factorizers}}

Tous les \emph{factorizers} partagent une même variable globale \texttt{to\_fact}, le nombre qu'ils sont en train de factoriser. Ceux-ci parcourent tous les entiers de 2 à $\sqrt{\texttt{to\_fact}}$, en vérifiant à chaque fois si l'entier en question divise \texttt{to\_fact}. Si c'est le cas, un facteur (pas nécessairement premier) a été trouvé, et la variable globale \texttt{to\_fact} est effectivement divisée par celui-ci, autant de fois que possible. Ensuite, le facteur est ajouté à la \emph{waiting list}, en notant son nombre d'occurrences---ici le nombre de fois qu'il a divisé \texttt{to\_fact}---, puis les \emph{factorizers} continuent leur travail.

Bien évidemment, les différents threads ne parcourent pas chacun tous les nombres entre 2 à $\sqrt{\texttt{to\_fact}}$. Ceux-ci se répartissent le travail: le premier thread itérant sur $i=2,2+n,2+2n,\dots$; le second thread itérant sur $i=3,3+n,3+2n,\dots$; etc. Si ce n'était pas le cas, augmenter le nombre de threads n'aurait strictement aucun intérêt!

Lorsque tous les \emph{factorizers} ont dépassé $\sqrt{\texttt{to\_fact}}$, ceux-ci attendent que la boucle principale choisisse un nouvel entier à placer dans \texttt{to\_fact}, puis recommencent leur travail.

\subsubsection*{La boucle principale}

Il est important de noter que la valeur de \texttt{to\_fact}, une fois que les \emph{factorizers} ont terminé leur travail, est un facteur premier du nombre initial. %TODO: maybe add a drafty proof

Le rôle de la boucle principal est double: tout d'abord, elle va récupérer ce facteur premier et le traiter; ensuite, si la solution n'a pas encore été trouvée, elle va choisir un nouvel entier de la \emph{waiting list} et le placer dans la variable \texttt{to\_fact} avant de relancer les \emph{factorizers}.

\paragraph{Traitement du facteur}
Si celui-ci n'est pas 1, alors la boucle principale va parcourir chaque entier de la \emph{waiting list} et diviser celui-ci par le facteur. Ensuite, deux situations sont possibles:
\begin{itemize}
    \item les \emph{readers} n'ont pas fini de lire les fichiers; dans ce cas, le facteur est simplement ajouté à la \emph{prime list}, en prenant soin de noter le nombre de fois qu'il a divisé un nombre de la \emph{waiting list} dans son nombre d'occurrences;
    \item les \emph{readers} ont terminé leur lecture; dans ce cas, si le facteur n'a divisé aucun nombre de la \emph{waiting list}, il s'agit de la solution, et le programme termine.
\end{itemize}

\paragraph{Choix d'un nouvel entier}
Si la solution n'a pas été trouvée, un nouvel entier est choisi pour \texttt{to\_fact}: il s'agit du plus petit entier de la \emph{waiting list}, trouvé en faisant une simple recherche en $\mathcal{O}(n)$; en effet, la liste n'est pas ordonnée.

\subsubsection*{Les \emph{readers}}

Les \emph{readers} sont des threads génériques qui lisent des entiers au format BigEndian depuis \emph{file descriptor} et placent ceux-ci dans la waiting list. Leur fonctionnement exact est en vérité un peu plus complexe que cela.

Pour chaque nombre lu, un \emph{reader} va parcourir la \emph{prime list} et diviser le nombre par chaque facteur premier autant de fois que possible, en mettant à jour le nombre de fois que ce facteur a divisé. Cela est nécessaire car les nombres lus n'ont pas eu l'occasion d'être divisés par la boucle principale lors du traitement du facteur.

C'est là la seule raison d'existence de la \emph{prime list}---et celle-ci est d'ailleurs détruite lorsque le dernier \emph{reader} a terminé son travail. Avant de la désallouer, cependant, le dernier \emph{reader} la parcours une dernière fois: en effet, si l'un des facteurs a un nombre d'occurrences de 1, alors il s'agit de la solution et le programme doit se terminer.

\subsection*{Mécanismes de synchronisation}

\subsubsection*{Les \emph{readers} et la boucle principale}

Ces deux parties doivent être synchronisées à la manière d'un producteur-consommateur où il n'y aurait qu'un seul consommateur: la boucle principale. Celle-ci attend qu'un \emph{reader} lise un entier et le place dans la \emph{waiting list}, afin de pouvoir le mettre dans \texttt{to\_fact}.

Nous avons donc un sémaphore \texttt{sem\_full}, dont la valeur est égale au nombre d'entiers présents dans la \emph{waiting list}. À chaque fois qu'un \emph{reader} ou un \emph{factorizer} ajoute un entier dans celle-ci, le sémaphore est posté, et à chaque fois que les \emph{factorizers} ont besoin d'un nouvel entier à factoriser, la boucle principale effectue un wait sur ce sémaphore pour s'assurer qu'il peut en effet récupérer un entier de la \emph{waiting list}.

\subsubsection*{La modification de l'état global}

L'état global, constitué notamment de la \emph{waiting list}, de la \emph{prime list} et de \texttt{to\_fact}, peut être sans risque accédé en lecture mais doit toujours être protégé par une unique mutex lors d'un accès en écriture. Il s'agit de la même mutex pour toutes ces données, car la modification de d'une partie de l'état global a systématiquement un impact sur le reste.

\subsubsection*{Commande des \emph{factorizers}}

Puisque la parallélisation de la factorisation est interne, il faut que les \emph{factorizers} se synchronisent avec la boucle principale qui va choisir les nombres à factoriser un par un. La boucle principale va envoyer un signal aux factorizers pour qu'ils commencent à factoriser, ce qu'ils vont faire, puis ils vont attendre qu'eux tous aient fini avant d'envoyer un signal à la boucle principale et d'attendre le prochain nombre à factoriser.

La solution que nous avons développée est une extension du problème du rendez-vous, et se présente ainsi (son implémentation se trouve dans le fichier \texttt{factorizer.c}):
\lstinputlisting{factorizer-synchro}

On retrouve tout à fait ci-dessus l'algorithme classique du problème du rendez-vous, géré par la mutex \texttt{mutex} et le sémaphore \texttt{handshake}, mais des ajouts ont été faits pour gérér l'échange entre la boucle principale et les \emph{factorizers}. Nous allons commenter les lignes que nous avons ajoutées:
\begin{itemize}
    \item Lignes 2 et 3: avant de commencer à factoriser, le \emph{factorizer} attend le message envoyé par la boucle principale via le sémaphore \texttt{start} et le transmet au \emph{factorizer} suivant. De cette manière, la boucle principale ne doit envoyer ce message qu'une seule fois.
    \item Ligne 10: quand tous les \emph{factorizers} sont arrivés au bout de leur factorisation, on en profite pour décrémenter le sémaphore \texttt{start} que le dernier \emph{factorizer} à entrer avait posté en ligne 3 sans que personne ne l'attende. Il est important que cette opération se fasse à cet endroit précis pour éviter qu'un factorizer ne soit libéré par l'incrémentation du sémaphore \texttt{handshake} et ne commence sans attendre le signal de la boucle principale.
    \item Lignes 15 à 17: tous les \emph{factorizers} passant la barrière vont avoir le même comportement que pour le problème de rendez-vous classique sauf le dernier qui à la place d'incrémenter \texttt{handshake} va incrémenter \texttt{finish} pour signaler à la boucle principale que tous les \emph{factorizers} ont fini et sont prêts à recevoir un nouveau incrément de \texttt{start} en ligne 2.
\end{itemize}

Il suffit ensuite à la boucle principale de poster \texttt{start} puis d'attendre \texttt{finish} dès qu'elle veut lancer les threads sur un nombre.

\subsection*{Analyse des performances}

Comme mentionné dans la section «Concept», notre algorithme marche particulièrement bien pour certains cas, et malheureusement il marche particulièrement mal pour d'autres. Pour mettre ces effets en évidence, nous mesuré ses performances sur trois types de tests en particulier, et nous allons commenter les résultats.

\subsubsection*{Premier cas: beaucoup de petits facteurs premiers}

\end{document}

